<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>My first three.js app</title>
		<style>
			body { margin: 0; }
		</style>
	</head>
	<body>
		<script src="js/three.js"></script>
		<script type="module">

            import { TrackballControls } from 'https://cdn.skypack.dev/three@0.129/examples/jsm/controls/TrackballControls.js';

			const scene = new THREE.Scene();
            const camera = new THREE.OrthographicCamera(
                window.innerWidth / -2,
                window.innerWidth / 2,
                window.innerHeight / 2,
                window.innerHeight / -2,
                -1000,
                1000
            )
            camera.zoom = 20;
            camera.updateProjectionMatrix();            

			const renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );

            const material = new THREE.PointsMaterial( { 
                color: 'white',
                size: 0.5,
                sizeAttenuation: false
            });

            //Controls
            const controls = new TrackballControls( camera, renderer.domElement );

            controls.rotateSpeed = 1.0;
            controls.zoomSpeed = 1.2;
            controls.panSpeed = 0.8;

            controls.noZoom = true;
            controls.noPan = false;

            controls.staticMoving = true;
            controls.dynamicDampingFactor = 0.3;

            controls.keys = [65, 83, 68];

            const zoomDirection = new THREE.Vector3();
            const minZoom = 1;
            const maxZoom = 1000000;

            function mousewheel(event) {
                event.preventDefault();

                const amount = event.deltaY / 100;
                const zoom = camera.zoom - amount;

                if (zoom >= minZoom && zoom <= maxZoom) {
                    const size = new THREE.Vector2();
                    renderer.getSize(size);

                    // zoom in to cursor, but zoom out to center of page
                    const mX = amount > 0 ? 0 : (event.clientX / size.x) * 2 - 1;
                    const mY = amount > 0 ? 0 : -(event.clientY / size.y) * 2 + 1;
                    zoomDirection.set(mX, mY, 0.0000001)
                        .unproject(camera)
                        .sub(camera.position)
                        .multiplyScalar(amount / zoom);

                    camera.position.subVectors(camera.position, zoomDirection);
                    controls.target.subVectors(controls.target, zoomDirection);
                    camera.zoom = zoom;
                    camera.updateProjectionMatrix();
                }
            }
            renderer.domElement.addEventListener('wheel', mousewheel, false);

            // Variables
            const geometry = new THREE.BufferGeometry();
            const vertices = []
            let particles;
           
            const createPoint = function (x, y) {
                vertices.push(x, y, 0)
            }

            const updateGeometry = function () {
                const points = new Float32Array(vertices);
                geometry.setAttribute( 'position', new THREE.BufferAttribute( points, 3 ) );
                particles = new THREE.Points( geometry, material );
            }

			const animate = function () {
				requestAnimationFrame( animate );
				renderer.render( scene, camera );
			};

            const randomNumber = (min, max) => { 
                return Math.random() * (max - min) + min;
            } 

            const getPointInBetweenByPerc = (pointA, pointB, percentage) => {
                var dir = pointB.clone().sub(pointA);
                var len = dir.length();
                dir = dir.normalize().multiplyScalar(len*percentage);
                return pointA.clone().add(dir);
            }

            const sleep = (time) => {
                return new Promise(resolve => setTimeout(resolve, time))
            }

            // Plot original points
            const points = [];
            const radius = 20;
            const segments = 3;
            const thetaStart = Math.PI / 2;
            const thetaLength = Math.PI * 2;

            for(let i = 0; i <= segments; i++){
                const segment = thetaStart + i / segments * thetaLength;
                const x = Math.cos(segment) * radius;
                const y = Math.sin(segment) * radius;
                points.push(new THREE.Vector3(x, y, 0))
                createPoint(x, y);
            }

            updateGeometry();
            scene.add(particles);
			animate();

            // Can be anything
            const startPoint = new THREE.Vector3(233983, 4324234);
            let prevPoint = startPoint;

            for(let i = 0; i < 5000000; i++){

                if(i % 100000 == 0){
                    await sleep(10);
                    updateGeometry();
                }

                const roll = Math.floor(randomNumber(0, points.length - 1));
                const p = getPointInBetweenByPerc(points[roll], prevPoint, 0.5);
                prevPoint = p;
                createPoint(p.x, p.y);
            }

            updateGeometry();
		</script>
	</body>
</html>